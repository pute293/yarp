Post Script について
参考：http://d.hatena.ne.jp/dayflower/20100203/1265185183
      http://tutorial.jp/graph/ps/psman.pdf

・構文規則
各トークンを順次実行していくだけ
ただし、{ } で定義されるプロシージャ内のトークンはそのプロシージャが実行されるまで評価されない

・スタック指向
    1 2 add == % => 3
        % 1 を push [ 1 ]
        % 2 を push [ 1 2 ]
        % add を実行（スタックから2つ pop して1つ push する）
        % => [ 3 ]
        % == を実行（スタックから1つ pop して表示する）
・各値を評価した結果がリテラルならそれを push, プロシージャやオペレータならそれを実行する
・束縛は以下の形式
    key val def
  key に val を束縛する、という。key は何でもいいが、普通は名前オブジェクトを使う
    /a (aaa) def    % 名前 a に文字列 aaa を束縛する。/ は lisp の quote(') みたいなもの
    a ==            % => (aaa)
    (abc) 20 def    % 文字列 abc に 20 を束縛する
    (abc) load ==   % load オペレータで一度スタックに積む必要がある
    1 50 def        % 数字でもOK
    1 load ==       % => 50
  また、こういうこともできる
    /a /b def   % 名前 a に名前 b を束縛
    a ==        % => /b
    a (ok) def  % a の評価結果である名前 b に文字列 ok を束縛
    b ==        % => (ok)

・push 操作や dup, copy といったオペレータはシャローコピーを作る
    /a (aaa) def    % 名前 a に文字列 aaa を束縛
    a a a           % スタックに a を3つ push => [ (aaa) (aaa) (aaa) ]
    dup             % スタックトップをコピーして push => [ (aaa) (aaa) (aaa) (aaa) ]
    3 copy          % スタックトップから3つコピーして push => [ (aaa) (aaa) (aaa) (aaa) (aaa) (aaa) (aaa) ]
    a 1 42 put      % a のインデックス 1 を 42 (*) に置き換える
    pstack          % スタックの内容を表示する。すべて置き換わっている
                    % => (a*a) (a*a) (a*a) (a*a) (a*a) (a*a) (a*a)
    [(a)] dup 0 get % [ [(a)] (a) ] 中身を取り出す
    0 42 put        % [ [(*)] ]     複合型の場合は中身がシャローコピーされる
・copy オペレータの挙動
    % 引数が配列、文字列、辞書の場合、中身だけがシャローコピーされ、元のオブジェクトは捨てられる
    [(ab)] dup      % [ [(ab)] [(ab)] ]
    5 array         % [ [(ab)] [(ab)] [null null null null null] ]
    copy            % [ [(ab)] [(ab)] ] 元の長さに切りつめられる
    dup 1 array copy% [ [(ab)] [(ab)] [(ab)] ]
    0 (xx) put      % [ [(ab)] [(ab)] ] 要素の再束縛は元の配列/文字列に影響しない
    0 get 0 42 put  % [ [(*b)] ]    要素の内容自体を変更すると元の配列/文字列も変化する
    % 辞書の場合、コピー先の要素はそのまま残る
    << /a 1 >> dup  % [ <</a 1>> <</a 1>> ]
    << /b 2 >> copy % [ <</a 1>> <</a 1 /b 2>> ]

・もっとも単純には、スタックには2種類ある。値が push される対象であるオペランドスタックと、束縛のスコープをつくる辞書スタック
  （実際にはグラフィックスの状態を保存するスタックなどもある）
・プロシージャ定義 { } はスコープを作らないことに注意
    /proc { 1 dict begin /n exch def { n == } end } def
    4 proc exec % => Error: /undefined n
・現在の辞書スタックのトップをカレント辞書という。def オペレータはカレント辞書に対して束縛を行う
  名前の参照は辞書スタックの上から底へ向かって行われる
  下側の辞書にある名前に再代入したいときは store を使う
    /a (aaa) def
    /b (bbb) def
    /c (ccc) def
    0 dict begin    % 新しく辞書を作ってpush(0 dict)、pop した辞書を辞書スタックに push（結果としてカレント辞書になる）
    /a (***) def    % 新しいスコープで束縛
    a ==            % => (***)
    b ==            % => (bbb)  辞書スタックを遡って値を参照する
    /c (xxx) store  % def でなく store を使うと…
    end             % 辞書スタックを pop
    a ==            % => (aaa)
    c ==            % => (xxx)  値が書き換わっている
・つまりPSは「辞書スコープ」。プロシージャでローカル変数を使いたいときは明示的に n dict begin ... end で囲ってやること
・辞書スタックの底には systemdict という辞書がある。またインタプリタの初期状態では userdict というのがカレント辞書になっている

・for オペレータ (init inc limit proc for) は繰り返しのたびに現在の値を push する。proc 内で pop してやらないとそれが残り続ける
    0 1 5 { } for   % 何もせず 6 回まわす（init eq limit のときも proc は実行されることに注意）
    pstack          % => [ 0 1 2 3 4 5 ]
・プロシージャは実行時まで評価されない。これによって名前による再帰ができる
    /fact {
        1 dict begin
            /n exch def                     % n に引数を束縛 (pop)
            n 0 eq { 1 } {                  % if(n == 0) push(1)
            n 1 ge { n n 1 sub fact mul }   % else if(n >= 1) push(n * fact(n)) ここで fact が参照できる
                   { null } ifelse } ifelse % else push(null)
        end
    } def
    5 fact ==   % => 120
・配列 [ ... ] の [ はマークを push しているだけなので、以下の二つは同じ
    0 [ 1 2 3 4 ]       % 普通のやり方 [ ... ]
    0 mark 1 2 3 4 ]    % [ の代わりに mark を push する
    % => [ 0 [ 1 2 3 4 ] ]

・即時評価される名前 (immediately evaluated name)
名前リテラルには //xxx の形を使うこともできる。この名前はスキャナ/パーサがそれを見つけた時点で
xxx 自体に評価される
    /d << /a 1 >> def
    /proc1 { //d begin /b 2 def end } def
    /proc2 {   d begin /b 2 def end } def
    /d << /a 1 >> def       % d を再束縛
    proc1
    [ d { } forall] ==      % => [/a 1]
    % proc1 は定義時に d を評価しているので再束縛された d は変更を受けない
    proc2
    [ d { } forall] ==      % => [/b 2 /a 1]
    % proc2 は実行時に d を評価するので再束縛された d が変更を受ける
    
名前の探索は通常通りカレント辞書から行われるが、束縛が実行時でなく定義時であることに注意が必要
    { 1 dict begin /n 1 def //n end }    % undefined error; 辞書が作られて n が定義されるのは実行時、//n の評価は定義時

似たような early bind は bind オペレータを使ってもできる
ただしこちらはオペレータを置き換えるだけで、プロシージャは置き換えない
    /add1 { add } def
    /add2 { add } bind def  % プロシージャ内のオペレータを bind オペレータ実行時の値に束縛する
    /add  { sub } def       % カレント辞書の add を上書き
    1 2 add1 ==             % => -1 カレント辞書の add が使われる
    1 2 add2 ==             % =>  3 元の add が使われる
    /add3 { add2 } bind def % プロシージャ add2 を束縛？
    /add2 { mul } def       % add2 を再束縛
    1 2 add3 ==             % => 2 再束縛された方の add2 が呼ばれる

・型とは別に、オブジェクトは二つに分けられる。リテラルと実行可能なもの。
スキャナ/パーサがトークンを見つけたとき、それが実行可能であれば実行し、そうでなければスタックに積む
デフォルトで実行可能なものは、オペレータとプロシージャ
実行可能かどうかは xcheck オペレータで判別できる
cvx オペレータでオブジェクトを実行可能に、cvlit オペレータでオブジェクトをリテラルに変換できる
いずれにせよ、変換前後のオブジェクトは内部要素を共有している
(1) cvx
    数値、辞書、真偽値は cvx で実行可能になっても、自身をスタックに積む動作を行うだけ
    null は何もしない（自分をスタックに積むこともない）
    配列は実行可能配列（プロシージャ）になる
    文字列は「実行可能文字列」になり、exec で実行できるようになる。他の言語の eval みたいなもの
    プロシージャ、オペレータは変化なし
        (3 2 add) exec      % 文字列 (3 2 add) をスタックに積むだけ
        3 2 /add exec       % => [ 3 2 /add ]
        (3 2 add) cvx exec  % => [ 5 ] 実行可能文字列は exec で実行できる
(2) cvlit
    cvx と逆に、オブジェクトをリテラルに変える。「実行不可能に変える」と言った方がわかりやすい。
    数値、辞書、真偽値、null は変化なし
    実行可能配列はただの配列になる
    実行可能文字列はただの文字列になる
    プロシージャ、オペレータは自分をスタックに積むだけになる
        1 2 /add load       % => [ 1 2 --add-- ]
        exec ==             % => 3
        1 2 /add load cvlit % => [ 1 2 --add-- ]
        exec ==             % => --add-- [ 1 2 ] add オペレータの動作が自分を積むだけになる
